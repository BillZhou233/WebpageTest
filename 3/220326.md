# 计算机编程与数据结构 #1 - 前缀函数与 KMP 算法（ver 1.00-B）

此处对 KMP 的解说主要以前缀函数切入，相关讲解思路参考自 [OI Wiki](https://oi-wiki.org/)，和大部分数据结构教材上对 KMP 算法的相关解说略有不同。如果需要考研，__请勿参考此处对 KMP 的讲解__，以对应的教材为准。不过，部分教材中对前缀函数（或者等效于前缀函数的名词）的解说并不完全，此时也可参考此处关于前缀函数的部分。

另外，不同的读者对不同版本的 KMP 解说理解效果也不同。如果实在不理解这个版本的话也不要勉强，可以试试看其他的解说。

## 前缀和后缀的定义

- __前缀__ 指从字符串的 __第一个字符__ 开始到某个字符结束所组成的一段子串，即 `s[0] ~ s[x1]`。
- __真前缀__ 指 __除了该字符串本身__ 以外的其他前缀，即上述的 `x1` 不为 `n - 1`。
- __后缀__ 指从字符串的某个字符开始到 __最后一个字符__ 结束所组成的一段子串，即 `s[x2] ~ s[n - 1]`。
- __真后缀__ 指 __除了该字符串本身__ 以外的其他后缀，即上述的 `x2` 不为 `0`。

## 前缀函数的定义

设有一个字符串 `s`（0 起点），长度 `n = s.size()`，定义其前缀函数 `pi[n]` 是一个 __长度为 `n` 的数组__。  
对于该数组的每一位 `pi[i]`，函数值表示 `s[0] ~ s[i]`（共 `i + 1` 位）所组成的子串中 __最长相等真前缀和真后缀__ 的长度，若不存在则函数值为 `0`。  
特别地，因为单个字符组成的子串没有真前缀和真后缀，故令 `pi[0] = 0`。

例如：对 `s = "aabaaab"`，`pi[]` 数组的长度为 `7`，坐标范围 `0 ~ 6`。

`pi[0] = 0`，因为子串 `"a"` 没有真前缀和真后缀。

`pi[1] = 1`，因为子串 `"aa"` 有一组相等真前缀和真后缀 `"a"`，长度为 `1`。

`pi[2] = 0`，因为子串 `"aab"` 无相等真前缀和真后缀。

`pi[3] = 1`，因为子串 `"aaba"` 有一组相等真前缀和真后缀 `"a"`，长度为 `1`。

`pi[4] = 2`，因为子串 `"aabaa"` 有两组相等真前缀和真后缀 `"aa"`、`"a"`，最长的一组长度为 `2`。

`pi[5] = 2`，因为子串 `"aabaaa"` 有两组相等真前缀和真后缀 `"aa"`、`"a"`，最长的一组长度为 `2`。

`pi[6] = 3`，因为子串 `"aabaaab"` 有一组相等真前缀和真后缀 `"aab"`，长度为 `3`。

故该字符串的前缀函数 `pi[7] = {0, 1, 0, 1, 2, 2, 3}`。

OI Wiki 上另有演示 `s = "abcabcd"`。

## 直接由定义计算前缀函数

以下是一个直接按照定义计算前缀函数的流程：

- 开始前直接赋值 `pi[0] = 0`。
- 外层循环，令 `i = 1 -> n - 1` 顺次计算从第 `1` 位开始每一位上的前缀函数值 `pi[i]`。
- 里层循环，令 `j = i -> 1`， 从最大的真前缀 / 真后缀长度 `i` 开始试。若当前长度为 `j` 的真前缀 / 真后缀相等则 `pi[i] = j`；否则 `--j` 继续试。
- 若里层循环试到 `1` 都没有找到符合条件的一组真前缀 / 真后缀，则此时`pi[i] = 0`。

这个流程的字符串比较次数达到 $n^2$ 级别，时间复杂度约 $O(n^3)$。

## 前缀函数计算方法的优化

下面的解说中，令字符串 `s` 第 `x - 1` 位（下称“前一位”）上的前缀函数值 `pi[x - 1]` 和之前的前缀函数值都已知，我们接下来计算第 `x` 位（下称“后一位”）上的前缀函数值 `pi[x]`。

### 优化一

首先我们考虑 __相邻两位__ 前缀函数中“后一位”上的前缀函数值相比“前一位” __增加__ 的情况。

根据定义，令 `i = x - 1`，则“前一位”上前缀函数 `pi[x - 1]` 所对应的子串 `s[0] ~ s[x - 1]` 中，长度为 `pi[x - 1]` 位的真前缀（`s[0] ~ s[pi[x - 1] - 1]`）和真后缀（`s[x - pi[x - 1]] ~ s[x - 1]`）__相等__。

所以，“后一位”上的函数值 `pi[x]` 相比于“前一位”上的函数值 `pi[x - 1]` 增加，当且仅当上述子串中 __真前缀的后面一个字符__ `s[pi[x - 1]]` 和 __真后缀的后面一个字符__ `s[x]` 也 __相等__。此时可以得到 `pi[x] = pi[x - 1] + 1`。

> 举例子：  
> 前 `x` 位（也就是 `s[0] ~ s[x - 1]`）：`abcd ... abc`  
> 第 `x` 位：`d`  
> 由 `pi[x - 1] == 3` 且 `s[3] == s[x] == 'd'`  
> 故 `pi[x] = pi[x - 1] + 1 = 4`

也就是说“后一位”上的前缀函数值相比“前一位”上的值要么 __增加 1__，要么不增加（也就是不变或者减少）。

经过这一优化，我们每次内层循环的 `j` 都不用从真前缀 / 真后缀长度的最大值开始试，而是直接从该位置上前缀函数可取的最大值 `pi[x - 1] + 1` 开始试，能够一定程度上减少比较的次数。

使用优化一优化流程，字符串比较次数达到线性级别，时间复杂度约 $O(n^2)$。

具体的时间复杂度分析过程请参考 OI Wiki。

### 优化二

在优化一中，我们只是考虑了计算“后一位”上前缀函数值的最好情况：`pi[x] = pi[x - 1] + 1` 当且仅当 `s[pi[x - 1]] == s[x]`。

但只是优化到 $O(n ^ 2)$ 还远远不够，若 `s[pi[x - 1]] != s[x]`，又应如何处理呢？

此时不妨试着找出 `s[0] ~ s[x - 1]` 中是否还存在 __其他的相等真前缀和真后缀__，然后取这组真前缀 / 真后缀的后一位判断是否相等。

在优化一中，我们根据定义得出了 `s[0] ~ s[x - 1]` 中长度为 `pi[x - 1]` 位的真前缀（`s[0] ~ s[pi[x - 1] - 1]`）和真后缀（`s[x - pi[x - 1]] ~ s[x - 1]`）相等。利用这一条件，让我们再回到前缀函数的定义，但是这次从子串开始。

对于前述的真前缀，也就是 `s[0] ~ s[pi[x - 1] - 1]`（共 `pi[x - 1]` 位）所组成的子串，其中最长的相等真前缀和真后缀的长度即为 __第 `pi[x - 1] - 1` 位上前缀函数的值__，即 `pi[pi[x - 1] - 1]`，为了方便起见，令 `m = pi[pi[x - 1] - 1]`，即 `m` 代表了 __前述真前缀中最长的相等真前缀和真后缀的长度__。

同时，由于前述真前缀和前述真后缀，也就是 `s[x - pi[x - 1]] ~ s[x - 1]` （共 `pi[x - 1]` 位）所组成的子串相等，`m` __也代表了前述真后缀中最长的相等真前缀和真后缀的长度__，且这两对真前缀 / 真后缀 __一共四个字符串也都相等__。

也就是说，前述真前缀中长度为 `m` 位的真前缀 `s[0] ~ s[m - 1]` 和前述真后缀中长度为 `m` 位的真后缀 `s[x - m] ~ s[x - 1]` 相等。

切换视角，对于 `s[0] ~ s[x - 1]` 这组子串来说，`s[0] ~ s[m - 1]` 和 `s[x - m] ~ s[x - 1]` __也是这组子串中的一对相等真前缀 / 真后缀__，其长度为 `m` 位。

> 举例子：  
> 前 `x` 位（也就是 `s[0] ~ s[x - 1]`）：`abac ... aba`  
> 第 `x` 位：`b`  
> 由 `pi[x - 1] == 3` 但 `s[pi[x - 1]] == 'c', s[x] == 'b'`  
> 故此时不符合条件，往前找 `m = pi[pi[x - 1] - 1] = pi[2] = 1`  
> 此时的 `s[m] == s[x] == 'b'`  
> 故 `pi[x] = m + 1 = 2`

此时便我们完成了一次相等真前缀 / 真后缀长度的迭代，对这对真前缀 / 真后缀，我们仍利用优化一中的结论，判断 `s[m]` 和 `s[x]` 是否相等。若相等，__则中止迭代__，且 `pi[x] = m + 1`；若不相等，则同理以 `m` 代原过程中的 `pi[x - 1]` __再进行一次迭代__，尝试是否能找到新的 `m` 值及其对应的一对相等真前缀 / 真后缀。

若某次迭代过程中出现了 `m = 0` 且 `s[0] != s[x]`，此时 __也中止迭代__，且 `pi[x] = 0`。（如果不中止迭代，会无限循环 `m = 0` 时尝试比较的步骤）

这个迭代的过程，用一句有点绕的话简单概括，就是“前面等于后面，前面的前面等于前面的后面也就等于后面的后面”（？

由此，我们可以得到优化二，一个 __不包含任何字符串间的比较__ 而只进行单个字符间比较的前缀函数计算流程。它的时间复杂度是 __线性__，即 $O(n)$。

## 写代码

经过优化一和优化二之后，我们开始写代码。按照 OI Wiki 上的原话：该算法的最终实现出人意料的短且直观。

```cpp
int pi[MAX], ...;

void prefixFunc(string s)
{
  int l = s.size();
  pi[0] = 0;
  for (int i = 1; i < l; ++i)
  {
    int m = pi[i - 1];
    while (m != 0 && s[m] != s[i]) m = pi[m - 1];
    pi[i] = (s[m] == s[i])? (m + 1): 0;
    // or pi[i] = (s[m] == s[i])? (m + 1): m;
  }
}
```

在这代码当中，`while` 循环体现了 `m` 迭代的过程。迭代中止有两种可能：一是迭代到 __有符合条件的__ `m` 使得 `s[0] == s[x]`；二是迭代到 `m == 0` 且 `s[0] != s[x]`，也就是说 __找不到符合条件的__ `m` 值。

特殊地，当 `m == 0` 且 `s[0] == s[x]` 时，我们也认为此时的 `m` 符合条件。也就是说跳出 `while` 循环时候若 `s[m] != s[x]` 时 __只有一种可能__ 就是此时 `m == 0`。因此最后这个三目运算符条件为假的取值填 `m` 和 `0` 都没问题。

## 前缀函数的应用：KMP

首先重复一遍，本期主要内容是前缀函数，KMP 只是作为前缀函数最经典的运用之一在这出现。因此，这里对 KMP 的解说主要以前缀函数切入，相关讲解思路参考自 [OI Wiki](https://oi-wiki.org/)，和大部分数据结构教材上对 KMP 算法的相关解说略有不同。如果需要考研，__请勿参考这里对 KMP 的讲解__，并以对应的教材为准。

例题：在一个长度为 `l1` 的句子（字符串）`a` 中查找一个长度为 `l2` 的单词（子串）`b` 的所有出现位置，以首字母出现的位置表示。  
（这个例题的实际运用比如 VSCode 的“查找所有匹配项”，或者 Control + F）

朴素的解法的复杂度为 $O(l1 \times l2)$。运用前缀函数，可以在线性时间范围内解决问题。

由于计算前缀函数是对 __一个字符串__ 进行计算，我们先构造一个新字符串 `s = b + '#' + a` 将原来的两个字符串连起来。上述表达式中 `a`、`b` 的意义如题面，`'#'` 为分隔符，且该字符 __不存在于 `a`、`b` 中__。

对于 `s` 的构造，你可能会有这样的疑问：一是为什么一定是 `b` 放在前面，`a` 放在后面；二是为什么 `b` 和 `a` 之间会有 `'#'` 这个分隔符。事实上，这整个构造方法限定了整个 `s` 任一位置上的前缀函数值 __一定不超过 `l2`__。

如何证明？首先考虑 `x == l2`，此时由 `s[l2] == '#'` 得到 `s[0] != s[l2]` 即 `pi[l2] = 0`.

接着考虑 `x < l2` 的情况，此时对应 `pi[x]` 的前 `l2` 位，即字符串 `b` 的前缀函数。根据定义，一个字符串所有真前缀 / 真后缀的长度均小于字符串本身长度，故 `pi[x] <= x < l2`。

最后考虑当 `x` 足够大时 `s` 第 `x` 位上的前缀函数值 `pi[x]`，它代表 `s[0] ~ s[x]`（共 `x + 1` 位）所组成的子串中最长相等真前缀和真后缀的长度。我们先假设 `pi[x] > l2`，那么上述子串中长度为 `pi[x]` 的真前缀 / 真后缀
相等，此时真前缀中的第 `l2` 位也就是 `'#'` 所在的位数和真后缀中的第 `l2` 位相等。

但根据定义，真前缀 / 真后缀 __不能等于原先的子串本身__，故真后缀的第 `0` 位只能是原先子串的第 `1` 位或者更后面的位数。也就是说，真后缀中的第 `l2` 位只能是原先子串中 `l2` 后面的位数。而原先子串中除了第 `l2` 位以外其余的位数 __均不可能出现 `'#'`__，故真后缀中的第 `l2` 位 __不可能是 `'#'`__。与上一段的结果矛盾，此时可以证明整个 `s` 任一位置上的前缀函数值一定不超过 `l2`。

由上述结论，我们考虑当 `x` 足够大时 `s` 第 `x` 位上的前缀函数值 `pi[x] == l2` 的情况。此时，上述子串中的前 `l2` 位和后 `l2` 位相等，而前 `l2` 位就是字符串 `b`。也就是说，我们此时能够找到字符串 `b` 在 `s` 中的一个出现为上述子串的后 `l2` 位（`s[x - l2 + 1] ~ s[x]`）所组成的子串。但是这里的字符位置坐标 __是相对 `s` 来说__，我们最终需要求 __相对 `a` 来说__ 的位置坐标。

根据字符串 `s` 的构造方法我们知道：当 `i > l2` 时，`s[i] = a[i - l2 - 1]`。代 `i = x - l2 + 1`，上述出现的首字母 __相对 `a` 来说的位置坐标为 `x - 2 * l2`__。

通过以上推导，我们有如下解决该问题的做法：构造字符串 `s = b + '#' + a`，求其前缀函数，但是在计算完某一位上的前缀函数 `pi[i]` 后加一步：若计算得到的 `pi[i] == l2`，则说明 `a[i - 2 * l2]` 开始长度为 `l2` 的子串为 `b` 的一个出现，此时记录下结果（输出或储存）。

因为计算前缀函数是线性的过程，这个做法的时间复杂度为 $O(l1 + l2)$，下面写成代码。

```cpp
int pi[MAX], ...;

void findAllOccurrence(string a, string b)
{
  string s = b + '#' + a;
  int l1 = a.size(), l2 = b.size(), l3 = s.size();
  pi[0] = 0;
  for (int i = 1; i < l3; ++i)
  {
    int m = pi[i - 1];
    while (m != 0 && s[m] != s[i]) m = pi[m - 1];
    pi[i] = (s[m] == s[i])? (m + 1): 0;
    if (pi[i] == l2) cout << i - 2 * l2 << endl;
  }
}
```

事实上，由于 `pi[x]` 有最大值 `l2`，故迭代时 `m` 的取值为 `[0, l2]`，也就是说 `pi[]` 数组可以不用开到 `l3` 的长度，只用开到 `l2 + 1` 即可。此外还需要再开另一个变量记录前一位上前缀函数的值。

## 补充说明

- 关于 KMP 的不同版本解释中，“前缀函数”可能会使用其他的名词来表示，但是整个的意思是差不多的。

  - 例如，[阮一峰的网络日志](http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html) 及他所参考的 [jBoxer](http://jakeboxer.com/blog/2009/12/13/the-knuth-morris-pratt-algorithm-in-my-own-words/) 中这个版本使用了“部分匹配表”来指代 `b` 串（原文为“搜索词”）的前缀函数。

  - 绝大多数的数据结构书和考研视频上使用一个名为“`next` 数组”的东西，它和前缀函数也有一定的关联，具体以书上为准。

  - 不过阮一峰版的 KMP 解说（使用“部分匹配表”）和我这边上课的课件（使用“`next` 数组”）都是用同一组示例来解说的，使用两种方式略有区别但大体思路一致。

- 对于洛谷上的 KMP 模板题 [P3375](https://www.luogu.com.cn/problem/P3375)，题目中不仅需要输出所有匹配项的位置，还需输出 `b` 串（原题面中为 `s2`）每个前缀的最长 border 长度，它也是指 `b` 串的前缀函数。
